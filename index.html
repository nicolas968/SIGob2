<html>
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="initial-scale=1, maximum-scale=1, user-scalable=no" />
    <title>ArcGIS Maps SDK for JavaScript Tutorials: Display a map</title>

    <style>
        html,
        body,
        #viewDiv {
            padding: 0;
            margin: 0;
            height: 100%;
            width: 100%;
        }
    </style>
    <link rel="stylesheet" href="https://js.arcgis.com/4.27/esri/themes/light/main.css">
    <script type="module" src=https://js.arcgis.com/calcite-components/1.10.0/calcite.esm.js></script>
    <link rel="stylesheet" type="text/css" href=https://js.arcgis.com/calcite-components/1.10.0/calcite.css />
    <script src="https://js.arcgis.com/4.27/"></script>
    <script>
        // mock car_position
        const populationServiceUrl = 'https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Census_Counties/FeatureServer'

        let carGeometry = {
            type: "point",
            longitude: -122.3321,
            latitude: 47.6062
        };

        require([
            "esri/config",
            "esri/Map",
            "esri/views/MapView",
            "esri/widgets/Search",
            "esri/rest/geometryService",
            "esri/Graphic",
            "esri/rest/support/BufferParameters",
            "esri/layers/FeatureLayer",
            "esri/geometry/Point",
            "esri/rest/support/AreasAndLengthsParameters",
            "esri/rest/support/RouteParameters",
            "esri/rest/support/FeatureSet",
            "esri/rest/route",
        ], function(
            esriConfig,
            Map,
            MapView,
            Search,
            GeometryService,
            Graphic,
            BufferParameters,
            FeatureLayer,
            Point,
            AreasAndLengthsParameters,
            RouteParameters,
            FeatureSet,
            route
        ) {

            esriConfig.apiKey = "AAPK703bbf4bf7b84c8ca9ee01606fe0430cbBQwAqSYc7dXT33E-W7HMyo4iS5Xb0rV-Rwzv6csCU14P0KvFCdrqXQU3jsIu6St";
            let points = []
            const map = new Map({
                basemap: "arcgis-navigation"
            });
            const view = new MapView({
                container: "viewDiv",
                map: map,
                center: [-122.690176,45.522054],
                zoom: 12
            });
            const search = new Search({  //Add Search widget
                view: view
            });
            view.ui.add(search, "top-right"); //Add to the map

            search.on('search-complete', function(result){
                console.log(result, 'search result')
                const point = new Point([result.results[0].results[0].feature.geometry.longitude, result.results[0].results[0].feature.geometry.latitude])
                const graphic = addGraphic("stop", point)
                points.push(graphic)
                console.log(points, 'points')
                getRoute(points).then((paths) => {
                    path = paths
                })
            });
            const carSymbol = {
                type: "picture-marker",
                url: "https://static.vecteezy.com/system/resources/previews/001/193/929/original/vintage-car-png.png",
                width: "100px",
                height: "48px"
            }

            const carAttributes = {
                name: "car",
                location: "Seattle"
            }

            const carGraphic = new Graphic({
                geometry: carGeometry,
                symbol: carSymbol,
                attributes: carAttributes
            });

            view.graphics.add(carGraphic);

            // https://services.arcgis.com/P3ePLMYs2RVChkJx/arcgis/rest/services/USA_Census_Counties/FeatureServer

            const populationFeatureLayer = new FeatureLayer({
                url: populationServiceUrl
            });

            map.add(populationFeatureLayer);

            const getCarBuffer = async () => {
                const bufferParams = new BufferParameters({
                    distances: [1],
                    unit: "kilometers",
                    geodesic: true,
                    bufferSpatialReference: view.spatialReference,
                    outSpatialReference: view.spatialReference,
                    geometries: [carGeometry]
                });
                const bufferedCar = await GeometryService.buffer('http://tasks.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer', bufferParams)

                return new Graphic({
                    geometry: bufferedCar[0],
                    symbol: {
                        type: "simple-fill",
                        color: [0, 0, 0, 0.2],
                        outline: {
                            color: [0, 0, 0, 0.5],
                            width: 2
                        }
                    }
                });
            }

            let carBufferGraphic = undefined
            getCarBuffer().then((buffer) => {
                carBufferGraphic = buffer

                view.graphics.add(carBufferGraphic);
            })

            view.graphics.removeAll()

            view.graphics.add(carGraphic);



            let interesectedGraphics = []

            // buffer loop
            setInterval(function() {
                getCarBuffer().then((buffer) => {
                    view.graphics.remove(carBufferGraphic);
                    carBufferGraphic = buffer
                    view.graphics.add(carBufferGraphic);

                    let query = populationFeatureLayer.createQuery();

                    query.geometry = carBufferGraphic.geometry;
                    query.spatialRelationship = "intersects";
                    query.returnGeometry = true;
                    query.outFields = [ "POPULATION" ];
                    populationFeatureLayer.queryFeatures(query)
                        .then(function(response) {
                            const promises = []

                            // clean up old intersected geometries
                            for (const intersectedGraphic of interesectedGraphics) {
                                view.graphics.remove(intersectedGraphic)
                            }
                            interesectedGraphics = []

                            // draw the intersected geometries
                            for (const feature of response.features) {
                                const intersectedGeometry = feature.geometry
                                const intersectedGeometryGraphic = new Graphic({
                                    geometry: intersectedGeometry,
                                    symbol: {
                                        type: "simple-fill",
                                        color: [0, 0, 0, 0.2],
                                        outline: {
                                            color: [0, 0, 0, 0.5],
                                            width: 2
                                        }
                                    }
                                });

                                interesectedGraphics.push(intersectedGeometryGraphic)
                                view.graphics.add(intersectedGeometryGraphic);
                            }


                            for (const feature of response.features) {
                                promises.push(new Promise(async (resolve, reject) => {
                                    const population = feature.attributes.POPULATION;
                                    const countyGeometry = feature.geometry;

                                    const intersectedGeometriesPromise = GeometryService.intersect(
                                        'http://tasks.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer',
                                        [countyGeometry],
                                        carBufferGraphic.geometry
                                    ).then((intersectedGeometries) => {
                                        // only 1 geometry
                                        const intersectedGeometry = intersectedGeometries[0]
                                        // calculate area
                                        return GeometryService.areasAndLengths(
                                            'http://tasks.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer',
                                            new AreasAndLengthsParameters({
                                                lengthUnit: 'kilometers',
                                                areaUnit: 'square-kilometers',
                                                calculationType: 'preserveShape',
                                                polygons: [intersectedGeometry]
                                            })
                                        )
                                    })

                                    const countyAreaPromise = GeometryService.areasAndLengths(
                                        'http://tasks.arcgisonline.com/arcgis/rest/services/Geometry/GeometryServer',
                                        new AreasAndLengthsParameters({
                                            lengthUnit: 'kilometers',
                                            areaUnit: 'square-kilometers',
                                            calculationType: 'preserveShape',
                                            polygons: [countyGeometry]
                                        })
                                    )

                                    const [intersectedGeometryArea, countyArea] = await Promise.all([intersectedGeometriesPromise, countyAreaPromise])
                                    const interesectedRatio = intersectedGeometryArea.areas[0] / countyArea.areas[0]

                                    // return ratio * population
                                    resolve(interesectedRatio * population)
                                }))
                            }

                            Promise.all(promises).then((results) => {
                                const totalPopulation = results.reduce((a, b) => a + b, 0)
                                document.getElementById('total-pop').innerHTML = totalPopulation
                            })

                            // this should not work lol


                        });
                })

                // Get sum of POPULATION_2020 based on the intersect of the buffer with the counties in the feature layer

            }, 100000)


            async function getRoute(points) {

                const routeUrl = "https://route-api.arcgis.com/arcgis/rest/services/World/Route/NAServer/Route_World/solve";

                const routeParams = new RouteParameters({
                    stops: new FeatureSet({
                        features: points
                    }),
                    returnDirections: true,
                    directionsLanguage: "es"
                });

                let ruta = []

                const data = await route.solve(routeUrl, routeParams)
                if (data.routeResults.length > 0) {
                    showRoute(data.routeResults[0].route);

                    ruta = data.routeResults[0].route.geometry.paths
                    return ruta
                    //showDirections(data.routeResults[0].directions.features);
                }
            }

            function showRoute(routeResult) {
                routeResult.symbol = {
                    type: "simple-line",
                    color: [5, 150, 255],
                    width: 3
                };
                console.log(routeResult)
                view.graphics.add(routeResult,0);
            }

            function showDirections(directions) {
                function showRouteDirections(directions) {
                    const directionsList = document.createElement("ol");
                    directions.forEach(function(result,i){
                        const direction = document.createElement("li");
                        direction.innerHTML = result.attributes.text + ((result.attributes.length > 0) ? " (" + result.attributes.length.toFixed(2) + " miles)" : "");
                        directionsList.appendChild(direction);
                    });
                    directionsElement.appendChild(directionsList);
                }

                const directionsElement = document.createElement("div");
                directionsElement.innerHTML = "<h3>Directions</h3>";
                directionsElement.classList = "esri-widget esri-widget--panel esri-directions__scroller directions";
                directionsElement.style.marginTop = "0";
                directionsElement.style.padding = "0 15px";
                directionsElement.style.minHeight = "365px";

                showRouteDirections(directions);

                view.ui.empty("top-right");
                view.ui.add(new Expand({
                    view:view,
                    content:directionsElement,
                    expanded:true,
                    mode:"floating"}), "top-right");
            }

            function addGraphic(type, point) {
                let color = "#ffffff";
                let outlineColor = "#000000"
                let size = "12px";
                if (type == "start") {
                    color = "#ffffff";
                } else if (type == "stop") {
                    color = "#000000";
                    outlineColor = "#ffffff";
                    size = "8px";
                } else {
                    color = "#000000";
                    outlineColor = "#ffffff";
                }
                const graphic = new Graphic({
                    symbol: {
                        type: "simple-marker",
                        color: color,
                        size: size,
                        outline: {
                            color: outlineColor,
                            width: "1px"
                        }
                    },
                    geometry: point
                });
                view.graphics.add(graphic);
                return graphic;
            }

            const origin = new Point([-122.690176,45.522054]); // [-122.690176,45.522054
            const stop =  new Point([-122.685792,45.515485]);
            const destination = new Point([-122.68782,45.51238]);

            // generate array of points
            points.push(addGraphic("start", origin));
            points.push(addGraphic("stop", stop));
            points.push(addGraphic("end", destination));

            let path = undefined
            let currentPointIndex = 0;
            let interpolation = 0.0; // max 1.0
            getRoute(points).then((paths) => {
                path = paths
            })

            // main loop
            let last = Date.now()
            setInterval(function() {
                if (interpolation > 1) {
                    interpolation = 0
                    currentPointIndex += 1
                    if (currentPointIndex >= path[0].length - 1) {
                        currentPointIndex = 0
                    }
                }
                const now = Date.now()
                const delta = now - last
                last = now
                interpolation += 0.01 * delta
                if (path) {
                    const currentPoint = path[0][currentPointIndex]
                    const nextPoint = path[0][currentPointIndex + 1]

                    const currentPointGeometry = {
                        type: "point",
                        longitude: currentPoint[0],
                        latitude: currentPoint[1]
                    }
                    const nextPointGeometry = {
                        type: "point",
                        longitude: nextPoint[0],
                        latitude: nextPoint[1]
                    }

                    const interpolatedPointGeometry = {
                        type: "point",
                        longitude: currentPointGeometry.longitude + (nextPointGeometry.longitude - currentPointGeometry.longitude) * interpolation,
                        latitude: currentPointGeometry.latitude + (nextPointGeometry.latitude - currentPointGeometry.latitude) * interpolation
                    }

                    carGeometry = {
                        type: "point",
                        longitude: carGraphic.geometry.longitude + 0.0001 * delta,
                        latitude: carGraphic.geometry.latitude
                    }
                    carGraphic.geometry = new Point(
                        interpolatedPointGeometry
                    )

                }

            },100000)

        });
    </script>


</head>
<body>
<div style="position: absolute; bottom:0; border-radius: 10px; padding:15px; z-index: 1; right: 0;">
    <calcite-list>
        <calcite-list-item label="Hiking trails" description="Designated routes for hikers to use." value="hiking-trails">
            <calcite-action slot="actions-end" icon="layer" text="Trails layer"></calcite-action>
        </calcite-list-item>
        <calcite-list-item label="Waterfalls" description="Vertical drops from a river." value="waterfalls">
            <calcite-action slot="actions-end" icon="layer" text="Waterfalls layer"></calcite-action>
        </calcite-list-item>
        <calcite-list-item label="Rivers" description="Large naturally flowing watercourses." value="rivers">
            <calcite-action slot="actions-end" icon="layer" text="Rivers layer"></calcite-action>
        </calcite-list-item>
    </calcite-list>
</div>

<div id="viewDiv">
</div>
<div style="position: absolute; top:0; background: beige; border-radius: 10px; padding:10px;">
    <span id="total-pop"/>
</div>
</body>
</html>